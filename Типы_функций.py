import inspect
import sys
#
#
# #print() #ввод данных в программу
# #input() #ввести данные в программе
# print(dir()) #вывести атрибуты определенного обьекта
#
# #print(type('Привет'))       #(str)string - строка
# #print(type(123))            #(int)integed - целое число
# #print(type(123.1))          #(float) - число с плавающей точкой
# #print(abs(-123))                               #(ads) убирает минус в числовом значение
# #print(len('123'))           #(len) - количество символов в строке ( так и в списке символов)
# #print(type(True and False)) #(bool)boolean - булевы значения(одно из двух значений верно и неверно)
#                                                                    #and (и) or (или)
#                 #(sum()) сумма чисел в списке
#                 #(sorted()) сортировка списка в алфавитном порядке
#
# #print(input("Как дела? "))   #print(input()) - ввод данных в программу введенных в программе
# #input(999  )
#
# #my_string = input('какой год? ')
# #print(len('какой год? '))
#
# print('Ввод данных')
# print(input('Напиши слово  ').count('')-1)     #количество символов в написанном слове в программе
#
# input('какой год? '.upper())                     #большие буквы
# input('какой год? '.lower())                     #маленькие буквы
# input('какой год? '.replace(' ',''))             #замена что-то на что-то
# input('какой год? '[0])
# input('какой год? '[-1])
#
# print('Особенности  списков и их редактирования')
# r0 = ["6","ytu", 6]                  #(тип list) изменяемый список (только в квадратных скобках)
# print(r0)
# print(type(r0))
# r1 = ("6","ytu", 6)                 #(тип tuple)КОРТЕЖ - неизменяемый список(можно вообще без скобок (круглых) )
# print(r1)
# print(type(r1))
# r2 = {'Anna': 9091788787,'Anton': 7873436754,'Sasha':3452132324} #(тип dict) - (ключ : значение) только фигурные скобки
# print(r2)
# print(type(r2))
#
# r = (['wi','hi','end'],'sr',87,57)
# print(r)
# print((type(r)),'(КОРТЕЖ и квадратные скобки в нем)')
# r[0][1] = 'cool' #в кортеже можно заменять элементы в квадратных скобках (1.номер индекса элементов в квадратных скобках из всего списка [0], 2.номер индекса в квадратных скобках [1]
# print('В КОРТЕЖЕ можно заменять элементы в квадратных скобках')
# print(r)
#
#
# print('Редактировние списка')
#food = ['apple', 'banana', 456, 789]
# print(food)
# food[1] = 'go'                      #замена в списке
# print(food)
# food.remove('apple')                #удаление из списка с помощью конкретного имени в списке
# print(food)
# del food[1]                         #удаление из списка с помощью индекса определенной позиции
# print(food)
# food.append(123)                    #(.append()) добавление в основной список
# print(food)
# food.extend([777, 'ваза', 'слива']) #(.extend([]) добавление дополнительного списка в основной список
# print(food)
#
# food.extend('ХОЛ')                  #(.extend()) добавление в основной список каждого символа по отдельности или элементов из другого списка
# print(food)
# r = food.pop(4)                      # (.pop()) удаляет из списка элемент по индексу сохраняя его в переменной
# print(r)
# print('Наличие123',(123 in food))                  #проверка наличия элемента в списке
# print('Наличие123',(123 not in food))              #проверка отсутствия элемента в списке
# print(food)

# import os

# print('Словарь(тип списка)')
# r2 = {'Anna': 9091788,'Anton': 7873436754,'Sasha': 3452132324} #(тип dict()) - (ключ(key): значение(value(ценность))) только фигурные скобки

# u = [6, 4, 7]
# y = ['jh', 'de', 'ki']
# oi = dict(zip(y, u))
# print(oi)               #dist(zip()) объединение списков в словарь (ключ: значение)

## u = [6, 4, 7]
# y = ['jh', 'de', 'ki']
# print(dict(zip(y, u)))
# w = zip(y,u)            #zip() объединяет два списка соединяя попарно одинаковые индексы
# print(tuple(w))         #или указать другой тип, что будет общим кортежем (tuple)  в общем кортеже.
#
# print(r2)
# print(type(r2))
# print(r2['Anna'])                                                 #извлечение конкретного значения с помощью ключа (так же как при индексации)
# print(r2.get('Anton'))
# print((r2.get('Ant')), '(по умалчанию)')                          #(.get) нахождение и извлечение значения с помощью имени
# print(r2.get('Anto', 'Такого нет(вместо "None",'
#             'если не окажется в конкретном списке такого ключа)'))
# r2['Anna'] = 2346744543                                           #замена в списке у определенного ключа самого значения
# print(r2)
# r2['Misha'] =9807845683                                           #добавление дополнительного ключа со значением
# print(r2)
# r2.update({'Dima': 123456, 'Mas': 4563218785})                    #(.update) добавление дополнительного списка в общий список
# print(r2)
# del r2['Sasha']                                                   #(del) удаление ключа со значением из списка
# print(r2)
#
# t = r2.pop('Anna')                                                #(.pop) удаляет ключ сохраняя его значение в переменной
# print(r2)
# print(t)
#
# print(r2.keys())                                                  #(.keys) список только ключей основного списка
# print(r2.values())                                                #(.values) список только значений ключей основного списка
# print(r2.items())                                                 #(.items)возврат написание пары ключ значение
#database.add_user(user.usern, user.password)                #(.add_user) ввод в переменную данных типа словарь {usern: password}

#for key, values in kwargs.items()
     #setattr(self, key, values)                            #выписывая по отдельности ключ и значение.


#
# print('Множества (один из видов списков типа данных)')
# y = [6,5,5,4,'fghh', 'hhfdd', 0,6,4,3,7]
# list = set(y)
# print(y)
# print(list)                            #(set()) команда множества (упорядовачивание значений удаляя повторы)
#
# #print(list.remove(1))
# #print(list.remove(23))
# #print(list.discard(1))
# #print(list.discard(23))
#
#
# if first == second == third:                                # (if   :) - значение ЕСЛИ
#     print(3)                                                #(print ()) писать через 4-ре пробела
# elif first == second or first == third or second == third:  #(elif  :) - значение ЕСЛИ ТОЛЬКО
#     print(2)                                                #(else  :) - значение ИНАЧЕ
# else:                                                       #(or) - или
#     print(0)                                                #(and) - и
#                                                             #(not) - нет
                                                              #(*type) - произвольное количество позиционных параметров
                                                              #(**values) - произвольное количество именованных параметров
                                                              #map(название функции(переменная)
                                                              # sep = '\n' - перенос на новую строчку каждого элемента в списке.
# name = input('Введите имя: ')
# print('Привет, name)
# if name == 'Денис':                  # если конкретно что-то будет написано в переменной, (например 'Денис')
#        print('Здравствуй друг')            то можно уточнить и вывести (print) уже конкретную желаемую информацию
#                                                  для этой конкретной переменной.

# >>> set([1,2,3])
# {1, 2, 3}
# >>> tuple({5,6,7})
# (5, 6, 7)
# >>> list('hello')
# ['h', 'e', 'l', 'l', 'o']


# Чтобы добавить уникальные характеристики при создании класса, в отношении объектов den и max необходимо использовать конструкцию 'def __init__' — инициализатор

# class Human       -  инструкция для создания объектов и название класса
#     def __init__(инициализатор) (self(является указателем на сам объект ввиде созданной ниже переменной), name, ...)  атребуты - перемннные внутри класса
       #(методы(способности(то что умеет делать наш объект))-(характеристики (уникальные черты наших объектов))- функции внутри класса

       #print(Human.__mro__) #"__mro__" - показывает цепочку наследования для того класса

       #print(dir())         #"dir()? для получения атрибутов внутри данного пространства имен


# Скрытые атрибуты объекта класса и обращение к ним через "КАСТЫЛЬ" - _Figure - (название класса с нижним подчеркиванием)
#
# class Figure:
#     sides_count = 0
#     def __init__(self):
#         self.__sides = []       # __Скрытые атрибут
#         self._color = [1]        #_Приватный атрибут
#         self.filled = None

#if __name__== "__main__": # Конструкция блокировки для чтения в других местах этого класса

# print(Figure()._Figure__sides) - _Figure(кастыль)
# print(Figure()._color)

                   # Наследования классов
# Метод mro() воспроизводит цепочку наследования

# "pass" Даже если в дочернем классе отсутствуют дополнительные атрибуты или методы, а вместо этого используется заглушка


                   #Перегрузка операторов

# Метод '__lt__()' можно интерпретировать как «меньше чем» (Lower than). Этот метод переопределяет поведение стандартного оператора
# «меньше», осуществляя его перегрузку.

# isinstance() #Метод проверки чего либо

# Метод '__gt__()' интерпретируется как «больше чем»
#     return self.age
#
# def __lt__(self,other):
#     return self.age < other.age
#
# def __gt__(self, other):
#     return  self.age > other.age




                                   #Работа с файлами

#file = open(self.__file_name, 'a+', encoding='UTF-8') #при работе с рускоязычным текстом желательно прописывать encoding='UTF-8'
#all_info = self.get_products().split("\n")  #split("\n") - удаление какого-либо знака занесенного в кавычки,
                                                            # делая список из текста, разделяя по индексу весь текст между удаленным знаком

# with open(name, encoding='UTF-8') as file: #открытие и закрытие файла происходит через оператор "with"
#     for line in file:
#         for char in line:
#             print(char, end='')
#     print(file.tell()) #- расположение курсора после перебора "for"




                            # os —  operating system interfaces

# import os
#
#чтобы создать вложенные папки, можно использовать команду "os.makedirs(r'third\fourth')".
# Важно учитывать использование двойного обратного слэша (\\) и префикса "r" перед строкой.
#В Windows для этой цели используется обратный слэш (\), который в Python является специальным символом.
# Поэтому его необходимо либо экранировать с помощью двойного слэша (\\), либо использовать префикс "r" перед строкой, чтобы Python правильно интерпретировал путь.
# В Linux и macOS в качестве разделителя используется обычный слэш (/)
#
# print('Текущая директория:', os.getcwd()) #метод определения адреса в данный момент
# #os.mkdir('second')                        #метод 'mkdir' создает новую рабочую директорию в этой директории(если ее нет)
# if os.path.exists('second'):     # обращается с помощью команды 'path' к методу 'exists' (наличие директории в скобках).
#     os.chdir('second')    # метод 'chdir' изменяет рабочую директорию если она есть - (True)
#     os.path.abspath(file) # метод 'abspath' прописывает полный адрес до указанного места в скобках
# else:                 #а если ее нет (False)
#     os.mkdir('second')
#     os.chdir('second')
# print('Текущая директория:', os.getcwd())
# #os.makedirs(r'third\forg') # метод 'makedirs' для создания дополнительных папок в текущей директории.
#
# print(os.listdir()) #метод 'listdir' для выведения списка содержимого этого рабочего пространства.
#
# for i in  os.walk('.'): #(".") - текущая рабочая директория. "walk" - метод прочтения информации в текущей директории.
#     print(i)
#
# os.chdir(r'C:\Users\Саша\PycharmProjects\pythonProject\Домашниe задания')
# print('Текущая директория:', os.getcwd())
# print(os.listdir())
# file = [f for f in  os.listdir() if os.path.isfile(f)] #шаблон для сортировки файлов
# dict = [d for d in  os.listdir() if os.path.isdir(d)] #шаблон для сортировки директорий
# print(file)
# print(dict)
#
# os.startfile(file[17])  # 'startfile' - метод запуска файла
# print(os.stat(file[17]))  #(stat) - метод получения информации из файла
# print(os.stat(file[17]).st_mtime) # запрос определенной информации по файлу
# os.system('pip install random2')#можно прописать, что будет выполняться в терминале
#
# from pprint import pprint
# file = open(name, 'r')
# print(file.tell())    # Метод «tell» позволяет узнать позицию курсора в данный момент в этом файле,
# pprint(file.read())   #а метод «read» считывает полное содержимое текстового файла.
#
# Документация по модулю os: https://docs.python.org/3/library/os.html


                          #Исключения(ошибки)
# «traceback»(трассировка)(отчет) предоставляет два важных элемента: название класса ошибки и её описание.Его следует читать снизу вверх

# BaseException — это базовый класс для всех исключений в Python. От него наследуются как системные (SystemExit, KeyboardInterrupt, GeneratorExit), так и пользовательские (Exception).

# Блок else выполняется только в том случае, если в блоке try не возникло ошибок.

# Блок finally обычно используется для выполнения завершающих операций, таких как закрытие файлов или освобождение ресурсов,
# что гарантирует их выполнение независимо от результата выполнения основного кода.



                          # Стандартные функции с Ленивыми вычислениями

# Функция map() применяется для преобразования каждого элемента в коллекции с помощью заданной функции.

# Функция filter(): она используется для фильтрации элементов списка, оставляя только те, которые соответствуют условию.
# В нашем случае мы используем функцию "is_odd", которая возвращает True для нечётных чисел. Таким образом, с помощью
# "filter(is_odd, my_numbers)" мы получаем новый список, содержащий только нечётные числа из оригинального списка

#list_comp_1=[x*2 for x in range(1,5)] #пример генерации списков

#list_comp_2=[x*2 for x in collection if x>5] #пример генерации списков
# В списковой сборке может быть только одно условие if, то есть конструкций типа elif или else использовать нельзя.

#list_comp_3=[x*2 if x>5 else x*10 for x in collection] #пример генерации списков

# my_num = ['g', 6, 'F', 7]
# list_comp_4 = [x if type(x) == str else x * 5 for x in my_num] #С конструкцией if и else
# print(list_comp_4)

# list_comp_4 = [x * y for x in col for y in col_2]

# Иногда нам нужно создать функцию, которая будет делать очень короткую математическую операцию. Для этого придумали лямбда-функции.
# my_fun = lambda x: x*10
# print(my_fun(x=7))

# my_n = [1, 2, 3]
# my_fun = map(lambda x: x*10, my_n)
# print(list(my_fun))

# list_1 = [5, 7, 3, 8, 4]
# list_2 = [8, 4, 2, 9, 0]
# mp = map(str, list_1)
# zp = zip(list_1, list_2)
# ran = range(10, 23)
#
# print(list(mp))
# print(list(zp))
# print(list(ran))


                              #Работа с потоками

# import os
# print(os.cpu_count()) #Количество доступных физических ядер

# from threading import Event - класс определения очереди выполнения команд.
# even = Event() (event.wait()(ожидание выполнения set); event.set()(первостепенное выполнение команд перед строчкой  set); event.clear()(удаление команды set после её вызова))
# from multiprocessing import pool #это класс для автоматического распределения задач между несколькими процессами


                            #Сторонние библиотеки

# python -m venv venv команда в терминале, чтобы создать вертуальное окружение.
# Это позволит изолировать зависимости проекта и избежать конфликтов с другими библиотеками.
# Параметр '-m venv' указывает на выполнение модуля 'venv',
# что расшифровывается как «virtual environment» (виртуальное окружение) и потом идет название папки, в которую будет установлен Python со всеми необходимыми зависимостями.

# 'venv\Scripts\activate.bat' #эта команда в терминале для активации виртуального окружения.

# pip freeze > requirements-def.txt # команда для создания файла со списком всех рагруженных библиотек.

# pip list # команда вывода списка загруженных библиотек

# pip freeze # команда для проверки, какие пакеты установлены в данный момент

# В терминале, чтобы удалить или установить библиотеку 'pip install ...' или 'pip uninstall ...'(... - название файла)



                            # Интроспекция
from pprint import pprint
from sys import getsizeof

import requests
import inspect
import sys

# help() #Эта функция предоставляет информацию, которую разработчик заложил в библиотеку, функцию или класс, то есть выводит «docstrings»

class Func:
    def __init__(self):
        self.it = 4
it = 8
tr = Func()
# print(tr. __name__) # функция возвращает первоначальное имя.
# print(type(it) is int) # идет уточнение через булево значение к чему относиться переменная
# print(dir(Func)) # список всех методов и функций которые можно применить к объекту.
# print(hasattr(tr, 'it')) #проверка наличия атрибутов в классе.
# print(getattr(tr, 'it'))  #определения значения определенного атрибута в классе.
# print(getattr(tr, 'u', 'Перехват исключения (синтаксическая ошибка), потому что нет такого атрибута'))

# for at_name in  dir(requests):
#     name = getattr(requests, at_name) #С помощью функции 'getattr' можно пройтись по всем переменным, функциям
#     print(at_name, type(name))       #и классам библиотеки 'requests'. Это делается с помощью функции 'dir'.

# print(callable(tr))
# print(callable(tr.it)) #функция проверяет можно ли вызвать этот класс или объект того же класса или нет.
# print(isinstance(it, int)) #Метод проверки чего либо
# print(inspect.ismodule(requests)) #функция проверяет, является ли это библиотекой или нет.
# print(inspect.isclass(Func)) #функция проверяет является ли это классом.
# print(inspect.isbuiltin(Func)) #функция проверяет является ли функция вшитой и встроенной в Пайтон.
# som_func = inspect.getmodule(Func)  #с помощью функции можно определить тип и путь.
# print(type(som_func), som_func)
# http: // docs.python.org / 3 / library / inspect.html #ссылка на модуль 'inspect'

# print(sys.version)
# print(sys.version_info)
# pprint(dir(__builtins__)) #выводит все функции и переменные, которые изначально встроенные в Пайтон.

# def func(x):
#     if sys.version.split(' ')[0] == '3.12.6': #Проверка версии Питона для правильной обработки функции через 'split'
#                                               #или обработки исключения
#         return x + 10
#     else:
#         raise Exception('Недопустимая версия')
# print(func(3))

print('байт:', getsizeof(Func)) #функция возвращает размер объекта в байтах.